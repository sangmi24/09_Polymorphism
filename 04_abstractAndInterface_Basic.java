package com.kh.chap02_abstractAndInterface.part02_family.model.vo;

public interface Basic {  //사람이라면 당연히 해야하는 행동들을 정의만 해둔 인터페이스 (먹기, 자기)

	/*
	 * * 인터페이스
	 * 상수 필드와 추상 메소드들로만 이루어진 추상클래스의 변형체(종특)
	 * 
	 *  [ 표현법 ]
	 *  접근제한자 interface 인터페이스명 { 
	 *     
	 *     // 필드부 => 상수필드만 작성
	 *     
	 *     // (생성자부 안씀=> 추상클래스 들은 객체 생성이 안되기 때문에 생성자는 생성 안함)
	 *     
	 *     // 메소드부 => 추상메소드만 작성
	 *     
	 *  }
	 *  => 접근제한자는 생략 가능(생략 시 default 로 잡혀버림)
	 *  
	 * - 인터페이스에서 필드는 무조건 "상수필드" 로 작성해야만 한다.
	 * - 인터페이스에서 메소드는 무조건 "추상메소드"로 작성해야만 한다.
	 * - 무조건 내가 구현해야 할 것이 있을 때 인터페이스를 만들어서 상속 시켜주면 된다. 
	 * - 추상클래스와 다르게 좀 더 강한 규칙성, 통일성, 강제성을 가지는 것이 인터페이스다.
	 * - 클래스와는 다르게 인터페이스는 다중상속이 허용한다.
	 *   (결국 인터페이스는 메소드에 대한 정의만 하고 있어서
	 *   메소드 이름이 겹치더라도 최종 구현부분은 구현 클래스에서 이루어질 것이기 때문에 다중상속을 허용시킴
	 *   추가적으로 필드의 경우는 앞에 static 이 붙기 때문에 명시적으로 어디서 온것인지 구분 가능함) 
	 *   
	 *  *추상클래스와 인터페이스의 비교
	 *  1. 공통점
	 *  - 둘 다 미완성된 상태이므로 객체 생성이 불가능 하다. 단, 참조형 변수로써 사용은 가능하다.(즉, 다형성 적용 가능)
	 *  - 상속 (구현) 하는 클래스(자식)에 추상메소드들을 구현하도록 강제한다.  (미완성상태-> 오류가 난다. / 구현하면 오류가 없어짐) 
	 *  2. 차이점 
	 *  - 추상클래스의 경우는 클래스 내에 일반 필드, 일반메소드를 정의 할 수 있다지만(굳이 추상메소드가 없더라도 abstract 만 잘 붙인다면),
	 *    인터페이스의 경우는 모든 필드는 상수필드, 모든 메소드는 추상메소드로만 정의를 해야 한다.
	 *  - 존재하는 목적 자체가 다르다.
	 *  > 추상클래스 같은 경우는 추상클래스를 상속받아서 기능을 더 이용하고, 확장시키는데에 목적
	 *  > 인터페이스 같은 경우는 클래스의 기능(method) 구현을 강제하기 위한 목적으로 사용    
	 * (즉, 기능 구현을 강제함으로서 구현 객체의 같은 동작을 보장할 수 있다. => 적어도 자식들한테는 그 메소드들이 무조건 있어야 함) 
	 * 
	 * extends(확장시키다) vs  implements (구현하다)
	 * - 클래스간에 상속 관계일때 : 자식클래스명 extends 부모클래스명 
	 * - 클래스와 인터페이스의 상속 관계일때 == 구현 관계일때 : 자식클래스명 implements 인터페이스명
	 * - 인터페이스간의 상속 관계일때 : 자식인터페이스명 extends 부모인터페이스명1,부모인터페이스명2 => 다중상속이 가능하다.  
	 */
	
	//필드부 => 상수필드(static final)
	//public static final 자료형 변수명 = 값;
	/*public static final*/ int num = 10;
	//인터페이스에는 상수 필드만 정의할 수 있기 때문에 애초에 앞의 public static final 이 생략 가능하다.
	
	// 메소드부 => 추상메소드 (abstract)
	/*public abstract*/ void eat();
	 void sleep();
	//인터페이스에는 추상메소드만 정의할 수 있기 때문에 애초에 앞의 public abstract 부분이 생략 가능하다.
	
	
	
	
	
}
